# BabyStepGiantStep(BSGS)

集合 $S$ ,写像 $f:S\to S$ , $s,g\in S$ に対して、以下を満たす最小の非負整数 $t$ を求めます。(存在しないときは、そのことを検知する)
$$f^t(s)=g$$

ただし、以下の条件を満たす必要があります。 $f^i$ みたいなのは、 $f$ の $i$ 回合成です。
- ある $n\in\mathbb{N}$ が存在して、任意の $x\in S$ に対して $f^n(x)=x$ が成り立つ。
- 逆写像 $f^{-1}$ が存在する
- ある $m\in\mathbb{N}$が存在して $f^m$ が高速に求まる。

このとき、 $n,m,f^m$ が実際に求まれば、上記の $t$ が $O((m+\frac{n}{m})\log (m+\frac{n}{m}))$ で求まる。\
$m=\text{ceil}(\sqrt n)$ だと計算量 $(\sqrt n\log n)$で求まる!!!

<details>
  <summary> 手法 </summary>
  
  周期性から、 $t=0,1,\dots,n-1$ に対して条件を満たすかどうか確認すればよいです。なぜなら、
  $$f^j=f^{j \mod n}$$
  が成り立つからです。\
  まず、別処理で $t=0$ の時を調べておきます。これは $s=g$かどうか判定するだけです。
  \
  \
  $t=im-j$ と分解します。この時、 $1\leq i\leq \text{ceil}(\frac{n}{m})$ と $0\leq j< m$ なる $i,j$ について調べれば $t=1,2,\dots,n-1$ について調べたことになります。\
  こう分解したとき、
  $$f^{im-j}(s)=g\Leftrightarrow f^{im}(s)=f^{j}(g)$$
  $$\Leftrightarrow (f^m)^{i}(s)=f^{j}(g)$$
  となります。\
  ここで、 $i$ を固定してみることにします。\
  このとき、 $t$ を最小化するためには(存在すれば) $f^{im}(s)=f^{j}(g)$ なる最大の $j$ を使えばよいです。このとき、前処理で
  - $mp[x]$:(存在すれば) $x=f^j(h)$ なる最大の $j$
                                                                            
  というハッシュマップ(`std::map`)を用意しておくことで、 $j$ の検索が高速で処理できます。
  \
  \
  \
  \
  ということで、以下の手順を踏むことで(あれば)最小の $t$ を見つけることができました。
  
  1. $j=0,1,\dots,m-1$ に対して、 $f^j(g)$ を計算して $mp$ に突っ込んでおく。
  1. $i=1,2,\dots,\text{ceil}(n/m)$ に対して、 $mp[f^{im}(s)]$ を検索して、もしあれば $t=im-j$ が答え。

  ...計算量は $O(m+n/m)$ にハッシュマップの検索分がつきます。これは、 $m=\text{ceil}(\sqrt n)$ とすることで最小化できます。
  \
  \
  \
  なお、実用上は $m=\sqrt n+1$ とかでいい。
</details>

## 使い方
```cpp
bsgs<class S>(S s,S g,ll n,ll m,function<S(S)> f,function<S(S)> fm)
```
$S,s,g,n,m,f$ は上の通り。 $fm$ は $f^m$ です。\
$f,fm$ はラムダ式とかで渡してください。
