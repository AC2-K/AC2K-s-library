#line 1 "main.cpp"
#define PROBLEM "https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/all/GRL_5_C"

#line 1 "template.hpp"
#include<bits/stdc++.h>
using namespace std;
#define rep(i, N)  for(int i=0;i<(N);i++)
#define all(x) (x).begin(),(x).end()
#define popcount(x) __builtin_popcount(x)
using ll = long long;
//using i128=__int128_t;
using ld = long double;
using graph = vector<vector<int>>;
using P = pair<int, int>;
const int inf = 1e9;
const ll infl = 1e18;
const ld eps = 1e-6;
const long double pi = acos(-1);
const ll MOD = 1e9 + 7;
const ll MOD2 = 998244353;
const int dx[4] = { 1,0,-1,0 };
const int dy[4] = { 0,1,0,-1 };
template<class T>inline void chmax(T&x,T y){if(x<y)x=y;}
template<class T>inline void chmin(T&x,T y){if(x>y)x=y;}
#line 1 "data-structure/sparse_table.hpp"
template<class T>
class sparse_table {
    vector<vector<T>> table;
    vector<int> look_up;
public:
    sparse_table(const vector<T>& vec = {}) {
        int sz = vec.size();
        int log = 0;
        while ((1 << log) <= sz) {
            log++;
        }
        table.assign(log, vector<T>(1 << log));
        for (int i = 0; i < sz; i++) {
            table[0][i] = vec[i];
        }
        for (int i = 1; i < log; i++) {
            for (int j = 0; j + (1 << i) <= (1 << log); j++) {
                table[i][j] = min(table[i - 1][j], table[i - 1][j + (1 << (i - 1))]);
            }
        }
        look_up.resize(sz + 1);
        for (int i = 2; i < look_up.size(); i++) {
            look_up[i] = look_up[i >> 1] + 1;
        }
    }

    T prod(int l, int r) {
        int b = look_up[r - l];
        return min(table[b][l], table[b][r - (1 << b)]);
    }
};
///@brief sparse table
#line 3 "graph/lca.hpp"
class LCA {
    using graph = vector<vector<int>>;
    int n;
    graph g;
    vector<int> vs, in;
    sparse_table<pair<int,int>> seg;
public:
    LCA(const graph& g) :g(g), n(g.size()),in(n) { }
    void setup() {
        int p = 0;
        vector<pair<int,int>> vec(2 * n);
        function<void(int, int, int)> dfs = [&](int v, int par, int now_depth) -> void {
            in[v] = p;
            vec[p++]={now_depth,v};
            for (const auto& ch : g[v])if (ch != par) {
                dfs(ch, v, now_depth + 1);
                vec[p++] = { now_depth,v };
            }
        };
        dfs(0, -1, 0);
        seg = sparse_table<pair<int, int>>(vec);
    }

    int query(int u, int v) {
        if (in[u] >= in[v])swap(u, v);
        return seg.prod(in[u], in[v] + 1).second;
    }
};
///@brief Lowest Common Ancestor(最小共通祖先)
#line 5 "main.cpp"


int main(){
    int n;
    cin>>n;
    graph g(n);
    rep(v,n){
        int k;
        cin>>k;
        rep(i,k){
            int c;
            cin>>c;
            g[c].emplace_back(v);
            g[v].emplace_back(c);
        }
    }

    LCA lca(g);
    lca.setup();


    int q;
    cin>>q;
    while(q--){
        int u,v;
        cin>>u>>v;
        cout<<lca.query(u,v)<<'\n';
    }
}
