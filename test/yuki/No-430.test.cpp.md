---
data:
  _extendedDependsOn:
  - icon: ':question:'
    path: data-structure/hash_map.hpp
    title: HashMap
  - icon: ':question:'
    path: math/gcd.hpp
    title: math/gcd.hpp
  - icon: ':question:'
    path: math/mod_pow.hpp
    title: "mod pow(\u7E70\u308A\u8FD4\u3057\u30CB\u4E57\u6CD5)"
  - icon: ':x:'
    path: string/rolling_hash.hpp
    title: "Rollinghash(\u30ED\u30FC\u30EA\u30F3\u30B0\u30CF\u30C3\u30B7\u30E5)"
  - icon: ':question:'
    path: template.hpp
    title: template.hpp
  _extendedRequiredBy: []
  _extendedVerifiedWith: []
  _isVerificationFailed: true
  _pathExtension: cpp
  _verificationStatusIcon: ':x:'
  attributes:
    '*NOT_SPECIAL_COMMENTS*': ''
    PROBLEM: https://yukicoder.me/problems/no/430
    links:
    - https://yukicoder.me/problems/no/430
  bundledCode: "#line 1 \"test/yuki/No-430.test.cpp\"\n#define PROBLEM \"https://yukicoder.me/problems/no/430\"\
    \n#line 2 \"template.hpp\"\n#include<bits/stdc++.h>\n#define rep(i, N)  for(int\
    \ i=0;i<(N);i++)\n#define all(x) (x).begin(),(x).end()\n#define popcount(x) __builtin_popcount(x)\n\
    using i128=__int128_t;\nusing ll = long long;\nusing ld = long double;\nusing\
    \ graph = std::vector<std::vector<int>>;\nusing P = std::pair<int, int>;\nconstexpr\
    \ int inf = 1e9;\nconstexpr ll infl = 1e18;\nconstexpr ld eps = 1e-6;\nconst long\
    \ double pi = acos(-1);\nconstexpr uint64_t MOD = 1e9 + 7;\nconstexpr uint64_t\
    \ MOD2 = 998244353;\nconstexpr int dx[] = { 1,0,-1,0 };\nconstexpr int dy[] =\
    \ { 0,1,0,-1 };\ntemplate<class T>static constexpr inline void chmax(T&x,T y){if(x<y)x=y;}\n\
    template<class T>static constexpr inline void chmin(T&x,T y){if(x>y)x=y;}\n#line\
    \ 2 \"math/mod_pow.hpp\"\nnamespace library {\n\n///@brief mod pow(\u7E70\u308A\
    \u8FD4\u3057\u30CB\u4E57\u6CD5)\ntemplate <class T, class U = T>\nconstexpr T\
    \ mod_pow(T base, T exp, T mod){\n    U ans = 1;\n    base %= mod;\n    while\
    \ (exp) {\n        if (exp & 1) {\n            ans *= base;\n            ans %=\
    \ mod;\n        }\n        base *= base;\n        base %= mod;\n        exp >>=\
    \ 1;\n    }\n    return ans;\n}\n\n};  // namespace library\n#line 3 \"math/gcd.hpp\"\
    \nnamespace library {\ntemplate <typename T> constexpr inline T _gcd(T a, T b)\
    \ {\n    assert(a >= 0 && b >= 0);\n    if (a == 0 || b == 0) return a + b;\n\
    \    int d = std::min(__builtin_ctzll(a), __builtin_ctzll(b));\n    a >>= __builtin_ctzll(a),\
    \ b >>= __builtin_ctzll(b);\n    while (a != b) {\n        if (a == 0 || b ==\
    \ 0) {\n            return a + b;\n        }\n        if (a > b) {\n         \
    \   a -= b;\n            a >>= __builtin_ctzll(a);\n        }else{\n         \
    \   b -= a;\n            b >>= __builtin_ctzll(b);\n        }\n    }\n\n    return\
    \ a << d;\n}\ntemplate<typename T>\nconstexpr inline T ext_gcd(T a, T b, T &x,\
    \ T &y) {\n    x = 1, y = 0;\n    T nx = 0, ny = 1;\n    while(b) {\n        T\
    \ q = a / b;\n        std::tie(a, b) = std::make_pair(b, a % b);\n        std::tie(x,\
    \ nx) = std::make_pair(nx, x - nx * q);\n        std::tie(y, ny) = std::make_pair(ny,\
    \ y - ny * q);\n    }\n    return a;\n}\n\n};  // namespace library\n#line 4 \"\
    string/rolling_hash.hpp\"\n\nnamespace library {\n\n///@brief Rollinghash(\u30ED\
    \u30FC\u30EA\u30F3\u30B0\u30CF\u30C3\u30B7\u30E5)\nclass RollingHash {\n\tusing\
    \ ull = uint_fast64_t;\n    using i128 = __int128_t;\n    using u128 = __uint128_t;\n\
    \    // mod\n\tstatic constexpr ull msk30 = (1ul << 30) - 1;\n\tstatic constexpr\
    \ ull msk61 = (1ul << 31) - 1;\n\tconst string str;\n\tvector<ull> hash, pow;\n\
    \n    static constexpr ull mod = (1uL << 61) - 1;\n    static constexpr ull primitive_root\
    \ = 37;\npublic:\n\tstatic const uint mapping_max = (uint)'Z' + 2;\n\tstatic ull\
    \ base;\nprivate:\n\tconstexpr ull mul(const u128& a,const u128& b) const {\n\
    \        u128 t = a * b;\n\n\t\tt = (t >> 61) + (t & mod);\n\n\t\tif (t >= mod)\
    \ {\n\t\t\tt -= mod;\n\t\t}\n\n\n\t\treturn t;\n    }\n\n    constexpr ull mapping(const\
    \ char& c) const {\n\t\treturn (ull)c;\t//\u5909\u66F4\u3059\u308B?\n\t}\n\n\n\
    \    static inline ull generate() {\n\t\tmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\n\
    \t\tuniform_int_distribution<ull> rand(1uL, mod - 1);\n\t\treturn rand(engine);\n\
    \t}\t\n    static inline void generate_base() {\n\t\tif (base != 0){\n\t\t\treturn;\n\
    \t\t}\n\t\tull r = mod - 1;\n\n\t\twhile (_gcd(r, mod - 1) != 1 || r <= mapping_max){\n\
    \t\t\tr = generate();\n\t\t}\n\t\tbase = mod_pow<__uint128_t>(primitive_root,\
    \ r, mod);\n\t}\npublic:\n\texplicit RollingHash() :str() {\t}\n\n\texplicit RollingHash(const\
    \ string& str) :str(str) {\n\t\tgenerate_base();\n\t\tbuild();\n\t}\n\n\tvoid\
    \ build() {\n\t\thash.resize(str.size() + 1);\n\t\tpow.resize(str.size() + 1,\
    \ 1);\n\n\t\tfor (int i = 0; i < str.size(); i++) {\n\t\t\thash[i + 1] = mul(hash[i],\
    \ base) + mapping(str[i]);\n\t\t\tpow[i + 1] = mul(pow[i], base);\n\t\t\tif (hash[i\
    \ + 1] >= mod) {\n\t\t\t\thash[i + 1] -= mod;\n\t\t\t}\n\t\t}\n\t}\n\tull range(int\
    \ l, int r) const {\n        assert(0 <= l && l <= r && r <= str.size());\n\n\
    \        ull res = mod + hash[r] - mul(hash[l], pow[r - l]);\n\t\treturn res <\
    \ mod ? res : res - mod;\n\t}\n\tull get_all() const {\n\t\treturn hash.back();\n\
    \t}\n\tint size() const {return str.size();}\n\n    static int lcp(const RollingHash\
    \ &a, const RollingHash &b, const int &start_a, const int &start_b) {\n      \
    \  int ok = 0;\n        int ng = min(a.size() - start_a, b.size() - start_b) +\
    \ 1;\n\t\twhile (abs(ok - ng) > 1){\n\t\t\tint md = (ok + ng) >> 1;\n        \
    \    if (a.range(start_a, start_a + md) == b.range(start_b, start_b + md)){\n\
    \                ok = md;\n            }\n            else{\n                ng\
    \ = md;\n            }\n\t\t}\n\n\t\treturn ok;\n    }\n};\ntypename RollingHash::ull\
    \ RollingHash::base;\n\n};  // namespace library\n#line 3 \"data-structure/hash_map.hpp\"\
    \nnamespace library{\n\n/// @brief HashMap\n/// @tparam Key Key\u306E\u578B\n\
    /// @tparam Val Value\u306E\u578B\ntemplate <typename Key,\n          typename\
    \ Val,\n          uint32_t n = 1 << 20,\n          Val default_val = Val()\n \
    \         >\nclass hash_map {\n    using u32 = uint32_t;\n    using u64 = uint64_t;\n\
    \n    u64* flag = new u64[n];\n    Key* keys = new Key[n];\n    Val* vals = new\
    \ Val[n];\n\n    static constexpr u32 shift = 64 - std::__lg(n);\n\n    u64 r;\n\
    \    inline u32 get_hash(const Key& k) const {\n        return ((u64)k * r) >>\
    \ shift;\n    }\n\n    static constexpr uint8_t mod_msk = (1 << 6) - 1;\n\n  public:\
    \   \n    explicit constexpr hash_map(){\n        r = std::chrono::steady_clock::now().time_since_epoch().count();\n\
    \        r ^= r >> 16;\n        r ^= r << 32;\n    }\n    Val& operator[](const\
    \ Key& k) {\n        u32 hash = get_hash(k);\n\n        while (1) {\n        \
    \    if (!(flag[hash >> 6] &\n                  (static_cast<u64>(1) << (hash\
    \ & mod_msk)))) {\n                keys[hash] = k;\n                flag[hash\
    \ >> 6] |= static_cast<u64>(1)\n                                   << (hash &\
    \ mod_msk);\n                return vals[hash] = default_val;\n            }\n\
    \n            if (keys[hash] == k)return vals[hash];\n            hash = (hash\
    \ + 1) & (n - 1);\n        }\n    }\n\n    const Val* find(const Key&k)const{\n\
    \        u32 hash = get_hash(k);\n        while (1) {\n            if (!(flag[hash\
    \ >> 6] &\n                  (static_cast<u64>(1) << (hash & mod_msk))))\n   \
    \             return nullptr;\n            if (keys[hash] == k) return &(vals[hash]);\n\
    \            hash = (hash + 1) & (n - 1);\n        }\n    }\n};\n\n\n};  // namespace\
    \ library\n#line 5 \"test/yuki/No-430.test.cpp\"\nusing namespace std;\nusing\
    \ namespace library;\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"Ofast\"\
    )\n#pragma GCC optimize(\"unroll-loops\")\nint main(){\n    ios::sync_with_stdio(false);\n\
    \    cin.tie(nullptr);\n    string s;\n    int m;\n    cin >> s >> m;\n    RollingHash\
    \ S(s);\n    hash_map<uint64_t, int> hash_count;\n    rep(i, s.size()) {\n   \
    \     for (int length = 1; length <= 10 && i + length <= s.size(); length++) {\n\
    \            int j = i + length;\n            hash_count[S.range(i, j)]++;\n \
    \       }\n    }\n    long long ans = 0;\n\n    for (int i = 0; i < m; i++) {\n\
    \        string c;\n        cin >> c;\n        ans += hash_count[RollingHash(c).get_all()];\n\
    \    }\n    cout << ans << '\\n';\n}\n"
  code: "#define PROBLEM \"https://yukicoder.me/problems/no/430\"\n#include\"template.hpp\"\
    \n#include\"string/rolling_hash.hpp\"\n#include\"data-structure/hash_map.hpp\"\
    \nusing namespace std;\nusing namespace library;\n#pragma GCC target(\"avx2\"\
    )\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\nint\
    \ main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    string\
    \ s;\n    int m;\n    cin >> s >> m;\n    RollingHash S(s);\n    hash_map<uint64_t,\
    \ int> hash_count;\n    rep(i, s.size()) {\n        for (int length = 1; length\
    \ <= 10 && i + length <= s.size(); length++) {\n            int j = i + length;\n\
    \            hash_count[S.range(i, j)]++;\n        }\n    }\n    long long ans\
    \ = 0;\n\n    for (int i = 0; i < m; i++) {\n        string c;\n        cin >>\
    \ c;\n        ans += hash_count[RollingHash(c).get_all()];\n    }\n    cout <<\
    \ ans << '\\n';\n}"
  dependsOn:
  - template.hpp
  - string/rolling_hash.hpp
  - math/mod_pow.hpp
  - math/gcd.hpp
  - data-structure/hash_map.hpp
  isVerificationFile: true
  path: test/yuki/No-430.test.cpp
  requiredBy: []
  timestamp: '2023-04-06 22:29:32+09:00'
  verificationStatus: TEST_WRONG_ANSWER
  verifiedWith: []
documentation_of: test/yuki/No-430.test.cpp
layout: document
redirect_from:
- /verify/test/yuki/No-430.test.cpp
- /verify/test/yuki/No-430.test.cpp.html
title: test/yuki/No-430.test.cpp
---
